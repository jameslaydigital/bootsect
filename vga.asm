;▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
;▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
;▒▒▒▒▒┌─────────────────────────────────┐▒▒▒▒▒▒
;▒▒▒▒▒│ VGA FUNCTIONS                   │▒▒▒▒▒▒
;▒▒▒▒▒├─────────────────────────────────┤▒▒▒▒▒▒
;▒▒▒▒▒│     void set_bg ( color )       │▒▒▒▒▒▒
;▒▒▒▒▒│     void set_video_mode ()      │▒▒▒▒▒▒
;▒▒▒▒▒│     void set_pxl ( color, x, y )│▒▒▒▒▒▒
;▒▒▒▒▒└─────────────────────────────────┘▒▒▒▒▒▒
;▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
;▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒

set_bg:
    push bp
    mov bp, sp
    mov cx, [bp+4]  ;move arg 1 to cx
    mov bx, 0xA000  ;VGA video mem starts at 0xA0000
    mov es, bx  ;...because you can't directly set es.
    xor bx, bx  ;Nullify bx because we're done with it
    .start:
        cmp bx, 64000
        je .done
        mov word [es:bx], cx    ; actually write to video mem
        inc bx
        jmp .start
    .done:
    pop bp
    ret

set_video_mode:
    mov ah, 0x0     ;Set video mode
    mov al, 0x13    ;256-color
    int 0x10
    ret






set_pxl:
    ;;  set_pxl ( color, x, y )
    ;;      [ bp + 4 ] color 
    ;;      [ bp + 6 ] x 
    ;;      [ bp + 8 ] y 
    push bp
    mov bp, sp

    mov bx, 0xA000  ;VGA video mem starts at 0xA0000. The start address is too
    mov es, bx
    ;; CALCULATE OFFSET FOR X AND Y
    ;; ( y * numCols ) + x
    mov bx, [ bp + 8 ]      ; y coordinate
    mov ax, 320
    mul bx
    mov bx, ax
    add bx, [ bp + 6 ]      ; x coordinate
    xor cx, cx
    mov cx, [ bp + 4 ]      ; move color to cx
    mov [es:bx], cl    ; actually write to video mem

    pop bp
    ret

    set_character:
    ; color4, bmp6, x8, y10
        push bp     ;enter
        mov bp, sp

        mov bx, [bp+6]  ; the buffer
        ;; while thing < 0x10
        .loop:
        mov ax, [bx]    ; ax = buffer
        cmp ax, 0x10    ; if ( ax >= 0x10 )
        jge .end        ; break

            mov ax, [bx]    ; x
            add ax, [bp+8]  ; add to x offset
            add bx, 2       ; increment counter
            mov dx, [bx]    ; y
            add dx, [bp+10]  ; add to y offset
            add bx, 2       ; increment counter
            push dx ; push y first
            push ax ; then x
            mov ax, [bp+4]  ; color
            push ax

            mov word [holding], bx  ; save to local var

            call set_pxl
            add sp, 6       ; clean up params

            mov word bx, [holding]  ; restore from local var

            jmp .loop
        .end:

        pop bp
        ret



holding: dw 0x0

z_bmp:
    dw 0x01, 0x00
    dw 0x00, 0x01
    dw 0x10, 0x10   ;0x10 is the termination number

a_bmp: 
    dw 0x00, 0x00
    dw 0x00, 0x01
    dw 0x00, 0x02
    dw 0x00, 0x03
    dw 0x00, 0x04
    dw 0x00, 0x05
    dw 0x01, 0x03
    dw 0x02, 0x03
    dw 0x03, 0x03
    dw 0x01, 0x00
    dw 0x02, 0x00
    dw 0x03, 0x00
    dw 0x04, 0x00
    dw 0x04, 0x01
    dw 0x04, 0x02
    dw 0x04, 0x03
    dw 0x04, 0x04
    dw 0x04, 0x05
    dw 0x10, 0x10   ;0x10 is the termination number

b_bmp: 
    dw 0x00, 0x00
    dw 0x01, 0x00
    dw 0x02, 0x00
    dw 0x03, 0x00
    dw 0x04, 0x00

    dw 0x04, 0x01
    dw 0x04, 0x02
    dw 0x04, 0x03
    dw 0x04, 0x04
    dw 0x04, 0x05

    dw 0x00, 0x00
    dw 0x00, 0x01
    dw 0x00, 0x02
    dw 0x00, 0x03
    dw 0x00, 0x04
    dw 0x00, 0x05

    dw 0x01, 0x02
    dw 0x02, 0x02
    dw 0x03, 0x02
    dw 0x04, 0x02

    dw 0x01, 0x05
    dw 0x02, 0x05
    dw 0x03, 0x05
    dw 0x04, 0x05
    dw 0x10, 0x10   ;0x10 is the termination number

c_bmp: 
    dw 0x00, 0x00
    dw 0x00, 0x01
    dw 0x00, 0x02
    dw 0x00, 0x03
    dw 0x00, 0x04
    dw 0x00, 0x05

    dw 0x01, 0x00
    dw 0x02, 0x00
    dw 0x03, 0x00
    dw 0x04, 0x00

    dw 0x01, 0x05
    dw 0x02, 0x05
    dw 0x03, 0x05
    dw 0x04, 0x05

    dw 0x10, 0x10   ;0x10 is the termination number

j_bmp:
    dw 0x04, 0x00
    dw 0x04, 0x01
    dw 0x04, 0x02
    dw 0x04, 0x03
    dw 0x04, 0x04
    dw 0x04, 0x05
    dw 0x03, 0x05
    dw 0x02, 0x05
    dw 0x10, 0x10   ;0x10 is the termination number

m_bmp:
    dw 0x00, 0x00
    dw 0x01, 0x00
    dw 0x02, 0x00
    dw 0x03, 0x00
    dw 0x04, 0x00
    dw 0x05, 0x00

    dw 0x00, 0x01
    dw 0x00, 0x02
    dw 0x00, 0x03
    dw 0x00, 0x04
    dw 0x00, 0x05

    dw 0x03, 0x01
    dw 0x03, 0x02
    dw 0x03, 0x03
    dw 0x03, 0x04
    dw 0x03, 0x05

    dw 0x05, 0x01
    dw 0x05, 0x02
    dw 0x05, 0x03
    dw 0x05, 0x04
    dw 0x05, 0x05
    dw 0x10, 0x10   ;0x10 is the termination number

e_bmp:
    dw 0x00, 0x00
    dw 0x00, 0x01
    dw 0x00, 0x02
    dw 0x00, 0x03
    dw 0x00, 0x04
    dw 0x00, 0x05

    dw 0x01, 0x00
    dw 0x02, 0x00
    dw 0x03, 0x00
    dw 0x04, 0x00

    dw 0x01, 0x03
    dw 0x02, 0x03
    dw 0x03, 0x03

    dw 0x01, 0x05
    dw 0x02, 0x05
    dw 0x03, 0x05
    dw 0x04, 0x05

    dw 0x10, 0x10   ;0x10 is the termination number

s_bmp:
    dw 0x04, 0x00
    dw 0x03, 0x00
    dw 0x02, 0x00
    dw 0x01, 0x00

    dw 0x00, 0x00
    dw 0x00, 0x01
    dw 0x00, 0x02
    dw 0x00, 0x03

    dw 0x01, 0x03
    dw 0x02, 0x03
    dw 0x03, 0x03

    dw 0x04, 0x03
    dw 0x04, 0x04
    dw 0x04, 0x05

    dw 0x00, 0x05
    dw 0x01, 0x05
    dw 0x02, 0x05
    dw 0x03, 0x05
    dw 0x04, 0x05

    dw 0x10, 0x10   ;0x10 is the termination number

o_bmp:
    dw 0x00, 0x00
    dw 0x01, 0x00
    dw 0x02, 0x00
    dw 0x03, 0x00
    dw 0x04, 0x00

    dw 0x04, 0x01
    dw 0x04, 0x02
    dw 0x04, 0x03
    dw 0x04, 0x04
    dw 0x04, 0x05

    dw 0x03, 0x05
    dw 0x02, 0x05
    dw 0x01, 0x05

    dw 0x00, 0x05
    dw 0x00, 0x04
    dw 0x00, 0x03
    dw 0x00, 0x02
    dw 0x00, 0x01

    dw 0x10, 0x10   ;0x10 is the termination number

count: dw 0
